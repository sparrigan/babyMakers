{% extends 'd3_base.html' %}
{% block body %}
<br>
<center>
	<div class="ui right labeled input">
	  <input type="text" id="name_val" placeholder="Name">
	  <div class="ui dropdown label">
	    <div class="text" id="sex_val">Female</div>
	    <i class="dropdown icon"></i>
	    <div class="menu">
	      <div class="item">Male</div>
	      <div class="item">Female</div>
	    </div>
	  </div>
	</div>
	<br>
	<br>

	<button class="ui button" onclick="submitClick()">
	  Submit
	</button>
</center>
<!-- Script for initialising semantic dropdown -->
<script>
$('.ui.dropdown')
  .dropdown()
;
</script>


<br>


<script type="text/javascript">

//Global vars
var svg;
var movie_g;
var yScale;
var xScale;
var w_total = 1000;
var h_total = 250;
var barpadding = 1;
var padding = 20;
var margin = {top: 20, right: 20, bottom: 20, left: 20};
var w = w_total - margin.left - margin.right,
		h = h_total - margin.top - margin.bottom;
// Resolved promise to chain off for queueing movie rect updates
var update_rect_sequence = Promise.resolve();


//SVG container
svg = d3.select('body')
						.append('svg')
						.attr('width', w + margin.left + margin.right)
						.attr('height', h + margin.top + margin.bottom)
						.append('g')
						.attr('transform', 'translate('+margin.left+','+margin.top+')');

// Initial plot before choice
//TODO: Replace this with animation or existing actor values
d3.json("{{ url_for('get_d3_data', name='Nicholas', sex='M') }}", function(json) {
	// Extract data from json dict into a JS array of values
	var dvals = Object.keys(json).map(function(k) { return json[k]});
	// Setup plot with this data
	setup_plot(dvals);
});

// Plots name values
var setup_plot =  function(dataset) {
	//Create scales - build range as years.
	xScale = d3.scale.ordinal()
								 .domain(d3.range(1880,2011))
								 .rangeBands([0,w],0.05);
	yScale = d3.scale.linear()
								 .domain([d3.min(dataset), d3.max(dataset)])
								 .range([h,0]);
	// Create rects
	var rects =
		svg.selectAll('rect')
			 .data(dataset)
			 .enter()
			 .append('rect')
			 .attr( {
				 'class': 'barRect',
				//  Note that we here rescale our index to proper year
				 'x': function(d,i) {return xScale(i+1880);},
				 'y': function(d) {return yScale(d);},
				 'width': xScale.rangeBand(),
				 'height': function(d) {return h-yScale(d);},
				 'fill': function(d) {
					 return 'rgb(200,0,'
					 +Math.floor((1-yScale(d)/h)*255)
					 +')';}
					})
	// x Axis
	var xAxis = d3.svg.axis()
							.scale(xScale)
							.orient('bottom')
							.tickValues(d3.range(1880,2011,20));
	svg.append('g')
		 .attr('class', 'axis')
		 .attr('transform', 'translate(0,'+h+')')
		 .call(xAxis)

	// NOTE: HOW TO PLOT MOVIE RECTS AS ARBITRARY SHAPES:
	// Create a holder g element and then create curves symetrically (in x) around
	// the center x,y coordinate of that g element using m and c
	// paths =
	// 	svg.selectAll('path')
	// 	.data(dataset)
	// 	.enter()
	// 	.append('path')
	// 	.attr({
	// 		'd': "M50,100 c10,0 20,-10 20,-40 c20,-10 20,0 30,0",
	// 		'stroke-width': 2,
	// 		'stroke': "blue"
	// 	});

}

// Function launched when submit button clicked
function submitClick(event) {
	// Get name entered in form
	new_name = document.getElementById('name_val').value;
	new_sex = document.getElementById('sex_val').innerText;
	url = "/get_d3_data/" + new_name + "/" + new_sex;
	// Update rects with name birth values
	d3.json(url , function(json) {
		// Extract data from json dict into a JS array of values
		var dvals = Object.keys(json).map(function(k) { return json[k]});
		// Setup plot with this data
		update_rects(dvals);
	});
	// TODO: URL construct for movie posters:
	// http://image.tmdb.org/t/p/w92/jojz3Yw5tEqtILcqbEsO0GLEIJm.jpg
	// Find movies associated with actor/actress
	// act_name = "Humphrey Bogart";
	// Get movie data (currently defaults to server-set name)
	// TODO: Have use user-entered name
	// TODO: Have suggest possibilities on multiple returns
	url_movies = "/get_movie_data";
	d3.json(url_movies, function(json){
		// Extract list of objects from json wrapper
		movie_data = json.results;
		actor_id = json.actor_id;
		//Plot the movie_data
		plot_movie_points(movie_data, actor_id);
		// ra = Object.keys(json).map(function(k) { return [k, json[k]]});
	});
	return false;
}

// Plot points for movies returned from server
function plot_movie_points(movie_json, actor_id) {
	// Make group in which to store movies
	movie_g = svg.append('g');
	// Add rects for movie data
	var movie_rects = movie_g.selectAll('rect')
				 .data(movie_json, function(d) {return d.values[0];})
				 .enter()
				 .append('rect')
				 .attr({
					 'class': 'mrect',
					 'x': function(d) {return xScale(d.values[1])+xScale.rangeBand()/4;},
					 'y': function(d) {return 100;},
					 'width': xScale.rangeBand()/2,
					 'height': function(d) {return (h-100);},
					 'fill': 'black'
				 });
	// Add text for each movie
	// TODO: Make this actually useful (rollover zoom etc...)
	var movie_text = movie_g.selectAll('text')
				.data(movie_json)
				.enter()
				.append('text')
				.text(function(d) {return d.movie;})
				.attr({
					'class': 'mtext',
					'x': function(d) {return xScale(d.values[1])+xScale.rangeBand()/4;},
					'y': h-100
				})
				// Rotation of text: Crucial - give center of rotation too!
				.attr('transform',function(d,i){
					return 'rotate(-90,'+d3.select(this).attr("x")+','+d3.select(this).attr("y")+')';})

		// Begin requesting info from server to cull unimportant movies
		movie_cull(movie_json, actor_id);

};

// Return promise for checking whether star features in movie or not
function cast_check_promise(actor_id, movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/cast_check/" + String(actor_id) + '/' + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			// Also security check in case no bool value (although should get error)
			} else if (result.result == null) {
				reject(result.error)
			// If no errors then send result to resolve function
			} else {
					// Add movie_id to object that we return
					result['movie_id'] = movie_id
					resolve(result);
			}
		});
	});
}

// Return promise for getting score of movie
function score_check_promise(movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/movie_score/" + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			} else {
				console.log('RETURNING MOVIE SCORE, ', movie_id);
					// Pass back result and movie_id
					resolve([result, movie_id]);
			}
		});
	});
}

// Return promise for plotting rects - executed at end of queue
function score_rect_promise(response) {
	return new Promise(function(resolve, reject) {
		score_data = response[0];
		movie_id = response[1];
		console.log('RESPONSE IS ', response);
		// Here is where we call stuff for each movie update
		//Call function that calculates score given features from api
		score = calc_score(score_data);
		//Call function that adjusts size of movie bars here
		console.log('CALLING score_rect_adjust')
		score_rect_adjust(movie_id, score);
		// Don't forget that we need to resolve the promise in order to move on
		// the chain!
		resolve()
	});
}

// Setup and act on promises for removing films based on cast-list
function movie_cull(movie_json) {
	// Setup promises to find which movies can ignore
	var cc_prom_list = [];
	// List to store movies that do feature actor
	starring_movs = []
	for (mov in movie_json) {
		// Get movie_id for current movie
		movie_id = movie_json[mov].values[0];
		// Create promise for querying api via server for actor in movie
		cc_prom = cast_check_promise(actor_id, movie_id).then(function(response){
			console.log('Success!', response);
			// Remove movie if fails test, otherwise add id to list
			if (response.result == false) {
				remove_movie_bar(response.movie_id);
			} else {
				starring_movs.push(response.movie_id)
			}
		}, function(error) {
			console.log('Failed :(', error);
		});
		// Add promise to array (so can use Promise.all to act when all complete)
		cc_prom_list.push(cc_prom);
	}
	// When all cast queries return then begin checking their scores.
	Promise.all(cc_prom_list).then(function(value) {
		// TODO: Here launch a re-check for all errors we had
		console.log('ALL DONE!!!!');
		// Setup promises for evaluating scores of remaining movies
		check_scores(starring_movs);
	});
}


// Setup and act on promises for removing films based on movie scores
function check_scores(starring_movs) {
	// List to store promises for each remaining movie
	var score_prom_list = []
	// Create promises that query api for score of each remaining movie
	for (mov_id in starring_movs) {
		// Create promise for this movie_id
		score_prom = score_check_promise(starring_movs[mov_id]).then(function(response){
			// On completion (data received) add a new promise to chain to alter d3
			update_rect_sequence = update_rect_sequence.then(function() {
				// Chain new promise to queue, passing json results and movie_id
				return score_rect_promise(response);
			}).then(function(response) {
				// Anything after each promise fulfilled from queue to go here
				console.log('Just of top of queue is: ', response);
			})
		// Error from promise for getting score from api
		}, function(error) {
			console.log('Failed :(', error);
		});
		// Add initial (pre-queue) api promises to list for Promise.all
		score_prom_list.push(score_prom);
		}
	// Find when all promises have been added to update_rect_sequence queue
	Promise.all(score_prom_list).then(function(value) {
		// When all in queue, add final then to queue that triggers next part of viz
		update_rect_sequence.then(function() {
			console.log('SCORES ALL DONE!!!!');
			// TODO: CALCULATE TOP TEN WHEN HAVE ALL MOVIES HERE....
			//Using filter, sort or order?
		});
	});
}

var pop_lim = [999,0];
var vote_lim = [999,0];
popScale = d3.scale.linear()
							 .range([0,100]);
voteScale = d3.scale.linear()
							 .range([0,100]);

function calc_score(response) {
	// Extract features into array
	vals = [response.pop, response.vote];
	// Check whether need to update max/min values
	// TODO: THIS IS HORRIBLE! VECTORIZE!
	pop_lim[0] = d3.min([pop_lim[0], vals[0]]);
	pop_lim[1] = d3.max([pop_lim[1], vals[0]]);
	vote_lim[0] = d3.min([vote_lim[0], vals[1]]);
	vote_lim[1] = d3.max([vote_lim[1], vals[1]]);

	// Re-scale pop and vote features based on current dataset
	popScale.domain([pop_lim[0], pop_lim[1]]);
	voteScale.domain([vote_lim[0], vote_lim[1]]);

// Now apply scale to all rects we have scores for, and put others at min value


	// Normalize value of vote and poularity
	console.log('WHAT WE GET IN CALC_SCORE: ', response);
	return 0;
};

// TODO: NEED TO NORMALIZE BOTH THE FEATURES AND THEN ALSO THE TOTAL VALUE TO PLOT

// var mrect_scale = d3.scale.linear()
// 							 .domain([0, d3.max(new_dataset)])
// 							 .range([h,0]);
var max_rect = 0;
var min_rect = 0;

// Adjust movie rect according to scores as they're RECEIVED
function score_rect_adjust(mov_id, score) {

	// Turn rect green and adjust height
	movie_g.selectAll('rect.mrect')
				 .filter(function(d) {return d.values[0] == mov_id;})
				 .transition()
				 .duration(200)
				 .attr({
					 'fill': 'green'
				 });

}


// movie_g.selectAll('rect.mrect').attr('height', function(d){return (h-d3.select(this).attr('y'));});


// Removes a bar and text downwards when movie culled
function remove_movie_bar(remove_val) {
	movie_g.selectAll('rect.mrect')
				 .filter(function(d) {return d.values[0] == remove_val;})
				 .transition()
				 .duration(500)
				 .attr('y',1000)
				 .remove();
	// Remove associated text
	movie_g.selectAll('text.mtext')
				 .filter(function(d) {return d.values[0] == remove_val;})
				 .transition()
				 .duration(500)
				 .attr('x',-1000)
				 .remove();
}

// Update rects for name history when new data to be bound
function update_rects(new_dataset) {
	// Update yscale
	yScale = d3.scale.linear()
								 .domain([0, d3.max(new_dataset)])
								 .range([h,0]);
	//Update rects
	svg.selectAll('rect.barRect')
		 .data(new_dataset)
		 .transition()
		 .delay(function(d,i) {return i/131 * 500;})
		 .duration(950)
		 .attr({
			 'y': function(d) {return yScale(d);},
			 'height': function(d) {return h-yScale(d);},
			 'fill': function(d) {
								return 'rgb(200,0,'+Math.floor((1-yScale(d)/h)*255) +')';
								}
			});
}

</script>

{% endblock %}
