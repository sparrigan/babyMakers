{% extends 'd3_base.html' %}
{% block body %}
<br>
<center>
	<div class="ui right labeled input">
	  <input type="text" id="name_val" placeholder="Name">
	  <div class="ui dropdown label">
	    <div class="text" id="sex_val">Female</div>
	    <i class="dropdown icon"></i>
	    <div class="menu">
	      <div class="item">Male</div>
	      <div class="item">Female</div>
	    </div>
	  </div>
	</div>
	<br>
	<br>

	<button class="ui button" onclick="submitClick()">
	  Submit
	</button>
</center>
<!-- Script for initialising semantic dropdown -->
<script>
$('.ui.dropdown')
  .dropdown()
;
</script>


<br>


<script type="text/javascript">
		d3.json("{{ url_for('get_d3_data', name='Nicholas', sex='M') }}", function(json) {
			// Extract data from json dict into a JS array of values
			var dvals = Object.keys(json).map(function(k) { return json[k]});
			// Setup plot with this data
			setup_plot(dvals);
		});

var svg;
var yScale;
var xScale;
var w_total = 1000;
var h_total = 250;
var barpadding = 1;
var padding = 20;
// var yr_range = d3.range(1880,2011);

var margin = {top: 20, right: 20, bottom: 20, left: 20};
var w = w_total - margin.left - margin.right,
		h = h_total - margin.top - margin.bottom;

		svg = d3.select('body')
								.append('svg')
								.attr('width', w + margin.left + margin.right)
								.attr('height', h + margin.top + margin.bottom)
								.append('g')
								.attr('transform', 'translate('+margin.left+','+margin.top+')');

var setup_plot =  function(dataset) {
	//Create scales - build range as years.
	xScale = d3.scale.ordinal()
								 .domain(d3.range(1880,2011))
								 .rangeBands([0,w],0.05);
	yScale = d3.scale.linear()
								 .domain([d3.min(dataset), d3.max(dataset)])
								 .range([h,0]);

	// Create rects
	var rects =
		svg.selectAll('rect')
			 .data(dataset)
			 .enter()
			 .append('rect')
			 .attr( {
				 'class': 'barRect',
				//  Note that we here rescale our index to proper year
				 'x': function(d,i) {return xScale(i+1880);},
				 'y': function(d) {return yScale(d);},
				 'width': xScale.rangeBand(),
				 'height': function(d) {return h-yScale(d);},
				 'fill': function(d) {
					 return 'rgb(200,0,'
					 +Math.floor((1-yScale(d)/h)*255)
					 +')';}
					})

	var xAxis = d3.svg.axis()
							.scale(xScale)
							.orient('bottom')
							.tickValues(d3.range(1880,2011,20));

		svg.append('g')
			 .attr('class', 'axis')
			 .attr('transform', 'translate(0,'+h+')')
			 .call(xAxis)

	// NOTE: HOW TO DO THIS:
	// Create a holder g element and then create curves symetrically (in x) around
	// the center x,y coordinate of that g element using m and c
	// paths =
	// 	svg.selectAll('path')
	// 	.data(dataset)
	// 	.enter()
	// 	.append('path')
	// 	.attr({
	// 		'd': "M50,100 c10,0 20,-10 20,-40 c20,-10 20,0 30,0",
	// 		'stroke-width': 2,
	// 		'stroke': "blue"
	// 	});

}

// Function launched when submit button clicked
function submitClick(event) {
	// Get name entered in form
	new_name = document.getElementById('name_val').value;
	new_sex = document.getElementById('sex_val').innerText;
	url = "/get_d3_data/" + new_name + "/" + new_sex;
	// Update rects with name birth values
	d3.json(url , function(json) {
		// Extract data from json dict into a JS array of values
		var dvals = Object.keys(json).map(function(k) { return json[k]});
		// Setup plot with this data
		update_rects(dvals);
	});

	// TODO: URL construct for movie posters:
	// http://image.tmdb.org/t/p/w92/jojz3Yw5tEqtILcqbEsO0GLEIJm.jpg
	// Find movies associated with actor/actress
	// act_name = "Humphrey Bogart";
	url_movies = "/get_movie_data";
	d3.json(url_movies, function(json){
		// Extract list of objects from json wrapper
		movie_data = json.results;
		actor_id = json.actor_id;
		//Plot the movie_data
		plot_movie_points(movie_data, actor_id);
		// ra = Object.keys(json).map(function(k) { return [k, json[k]]});
	});
	return false;
}


function plot_movie_points(movie_json, actor_id) {

	// Make group in which to store movies
	movie_g = svg.append('g');

	// Add rects for movies
	var movie_rects = movie_g.selectAll('rect')
					// Bind data - no need for key lookup
				 .data(movie_json, function(d) {return d.values[0];})
				 .enter()
				 .append('rect')
				 .attr({
					 'class': 'mrect',
					 'x': function(d) {return xScale(d.values[1])+xScale.rangeBand()/4;},
					 'y': function(d) {return 100;},
					 'width': xScale.rangeBand()/2,
					 'height': function(d) {return (h-100);},
					 'fill': 'black'
		});


	// TODO: Make this actually useful (rollover zoom etc...)
	var movie_text = movie_g.selectAll('text')
				.data(movie_json)
				.enter()
				.append('text')
				.text(function(d) {return d.movie;})
				.attr({
					'class': 'mtext',
					'x': function(d) {return xScale(d.values[1])+xScale.rangeBand()/4;},
					'y': h-100
				})
				// Rotation of text: Crucial - give center of rotation too!
				.attr('transform',function(d,i){
					return 'rotate(-90,'+d3.select(this).attr("x")+','+d3.select(this).attr("y")+')';})

					// Now that plotted data launch promises
					// test_movie_json = movie_json;


					movie_cull(movie_json, actor_id);

};

// Promise for getting whether star features in movie or not
function cast_check_promise(actor_id, movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/cast_check/" + String(actor_id) + '/' + String(movie_id);
		// url = "/cast_check/" + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			// Also security check in case no bool value (although should get error)
			} else if (result.result == null) {
				reject(result.error)
			// If no error then send result to resolve function
			} else {
					// Add movie_id to object that we return
					result['movie_id'] = movie_id
					resolve(result);
			}
		})

	});
}

// Promise for getting score of movie
function score_check_promise(movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/movie_score/" + String(movie_id);
		// url = "/cast_check/" + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			} else {
					// Send data to resolve function to evaluate whether to adjust and
					// evaluate whether to keep movie or not
					resolve(result);
			}
		})

	});
}



// var test_movie_json


// Note: see end of first answer here for usage where we can perform a function
// when *all* promises fulfil (and presumably each promise can still perform it
// own fulfillment functions?)
// http://stackoverflow.com/questions/22539815/arent-promises-just-callbacks
// Promise.all([api(), api2(), api3()]).then(function(result) {
//     //do work. result is an array contains the values of the three fulfilled promises.
// }).catch(function(error) {
//     //handle the error. At least one of the promises rejected.
// });

function movie_cull(movie_json) {
	// Setup promises to find which movies can ignore
	var cc_prom_list = [];

	// TODO: NEED TO GET ACTOR_ID BACK FROM PREVIOUS API CALL
	// AND ITERATE BELOW OVER MOVIE_IDS THAT WERE RECEIVED
	starring_movs = []
	for (mov in movie_json) {
		// Get movie_id for current movie
		movie_id = movie_json[mov].values[0];
		// Create promise with controller for querying api for actor in movie
		cc_prom = cast_check_promise(actor_id, movie_id).then(function(response){
			console.log('Success!', response);
			// Remove movie if fails test, otherwise add id to list
			if (response.result == false) {
				remove_movie_bar(response.movie_id);
			} else {
				starring_movs.push(response.movie_id)
			}
		}, function(error) {
			console.log('Failed :(', error);
		});
		cc_prom_list.push(cc_prom);

	}

	Promise.all(cc_prom_list).then(function(value) {
		// TODO: Here launch a re-check for all errors we had
		console.log('ALL DONE!!!!');
		// Setup promises for evaluating scores of remaining movies
		check_scores(starring_movs);
	});
	// });

}


// Setting up score check promises once movies culled by cast
function check_scores(starring_movs) {
	// Setup promise for each remaining movie
	score_prom_list = []

	for (mov_id in starring_movs) {
		score_prom = score_check_promise(starring_movs[mov_id]).then(function(response){

			//Call function that adjusts size of movie bars here
			score_rect_adjust(response.movie_id);
			console.log(response);
		}, function(error) {
			console.log('Failed :(', error);
		});
		score_prom_list.push(score_prom);
	}

	// Setup promise for all movies returning
	Promise.all(score_prom_list).then(function(value) {
		// TODO: Here launch a re-check for all errors we had
		console.log('SCORES ALL DONE!!!!');

		//CALCULATE TOP TEN WHEN HAVE ALL MOVIES HERE....

	});
}


// Adjust movie rect according to scores as they're RECEIVED
function score_rect_adjust(mov_id) {
	// Turn rect green and adjust height
	movie_g.selectAll('rect.mrect')
				 .filter(function(d) {return d.values[0] == mov_id;})
				 .transition()
				 .duration(200)
				 .attr({
					 'fill': 'green'
				 });
}


// movie_g.selectAll('rect.mrect').attr('height', function(d){return (h-d3.select(this).attr('y'));});

// !!!!!!!
// TODO: Need to make sure that we pass the proper form of dataset
// When re-binding data to find exit values and remove

// Removes a bar downwards when movie culled
function remove_movie_bar(remove_val) {
	movie_g.selectAll('rect.mrect')
				 .filter(function(d) {return d.values[0] == remove_val;})
				 .transition()
				 .duration(500)
				 .attr('y',1000)
				 .remove();
	// Remove associated text
	movie_g.selectAll('text.mtext')
				 .filter(function(d) {return d.values[0] == remove_val;})
				 .transition()
				 .duration(500)
				 .attr('x',-1000)
				 .remove();
}



function update_rects(new_dataset) {

	yScale = d3.scale.linear()
								 .domain([0, d3.max(new_dataset)])
								 .range([h,0]);

	svg.selectAll('rect.barRect')
		 .data(new_dataset)
		 .transition()
		 .delay(function(d,i) {return i/131 * 500;})
		 .duration(950)
		 .attr({
			 'y': function(d) {return yScale(d);},
			 'height': function(d) {return h-yScale(d);},
			 'fill': function(d) {
								return 'rgb(200,0,'+Math.floor((1-yScale(d)/h)*255) +')';
								}
				});
}


</script>
{% endblock %}
