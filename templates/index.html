{% extends 'd3_base.html' %}
{% block body %}
<br>
<center>
	<div class="ui right labeled input">
	  <input type="text" id="name_val" placeholder="Name">
	  <div class="ui dropdown label">
	    <div class="text" id="sex_val">Female</div>
	    <i class="dropdown icon"></i>
	    <div class="menu">
	      <div class="item">Male</div>
	      <div class="item">Female</div>
	    </div>
	  </div>
	</div>
	<br>
	<br>

	<button class="ui button" onclick="submitClick()">
	  Submit
	</button>
</center>
<div class = "score_text"></div>
<div class="row">
<div class="plot_area"></div>
</div>

<!-- Script for initialising semantic dropdown -->
<script>
$('.ui.dropdown')
  .dropdown()
;
</script>


<br>


<script type="text/javascript">

// TODO: Scrape this for actor/actress names to consider: http://www.imdb.com/search/name?gender=male,female
// TODO: Use themoviedb api to check whether they have a first film before 2005, and discard if so
// TODO: Use googl trends API to get popularity data: http://www.google.com/trends/fetchComponent?hl=en-US&q=Michael%20Fassbender&cid=TIMESERIES_GRAPH_0&export=3
// TODO: Get remainder of data for NN from themoviedb
// TODO: Train NN

//Global vars
var svg;
var movie_g;
var yScale;
var xScale;
var xAxis;
var w_total = 1000;
var h_total = 250;
var barpadding = 1;
var padding = 20;
var pad_ratio = 0.05
var margin = {top: 20, right: 20, bottom: 20, left: 20};
var w = w_total - margin.left - margin.right,
		h = h_total - margin.top - margin.bottom;
// Resolved promise to chain off for queueing movie rect updates
var update_rect_sequence = Promise.resolve();
var start_yr = 1930;
var profile_url;
var min_movie_yr;
var max_movie_yr;
var celeb_name;


//SVG container
svg = d3.select('.plot_area')
						.append('svg')
						.attr('width', w + margin.left + margin.right)
						.attr('height', h + margin.top + margin.bottom)
						.append('g')
						.attr('transform', 'translate('+margin.left+','+margin.top+')');

// SVG container for score text
text_svg = d3.selectAll('.score_text')
	.append('svg')
	.attr('width', 800)
	.attr('height', 0)

// Initial plot before choice
//TODO: Replace this with animation or existing actor values
url = "/get_d3_data/Nicholas/M/" + start_yr;
d3.json(url, function(json) {
	// Extract data from json dict into a JS array of values
	var dvals = Object.keys(json).map(function(k) { return [parseInt(k), json[k]]; });
	// Setup plot with this data
	setup_plot(dvals);
});

// Plots name values
var setup_plot =  function(dataset) {
	//Create scales - build range as years.
	xScale = d3.scale.ordinal()
								 .domain(d3.range(1930,2011))
								 .rangeBands([0,w], pad_ratio);
	yScale = d3.scale.linear()
								 .domain([
									 d3.min(dataset, function(d){return d[1];}),
								 	 d3.max(dataset, function(d){return d[1];})
								 ])
								 .range([h,0]);
	// Create rects
	var rects =
		svg.selectAll('rect')
			 .data(dataset)
			 .enter()
			 .append('rect')
			 .attr( {
				 'class': 'barRect',
				//  Note that we here rescale our index to proper year
				 'x': function(d,i) {return xScale(d[0]);},
				 'y': function(d) {return yScale(d[1]);},
				 'width': xScale.rangeBand(),
				 'height': function(d) {return h-yScale(d[1]);},
				 'fill': function(d) {
					 return 'rgb(200,0,'
					 +Math.floor((1-yScale(d[1])/h)*255)
					 +')';}
					})
	// x Axis
	xAxis = d3.svg.axis()
							.scale(xScale)
							.orient('bottom')
							.tickValues(d3.range(start_yr,2011,20));
	svg.append('g')
		 .attr('class', 'axis')
		 .attr('transform', 'translate(0,'+h+')')
		 .call(xAxis)

	// NOTE: HOW TO PLOT MOVIE RECTS AS ARBITRARY SHAPES:
	// Create a holder g element and then create curves symetrically (in x) around
	// the center x,y coordinate of that g element using m and c
	// paths =
	// 	svg.selectAll('path')
	// 	.data(dataset)
	// 	.enter()
	// 	.append('path')
	// 	.attr({
	// 		'd': "M50,100 c10,0 20,-10 20,-40 c20,-10 20,0 30,0",
	// 		'stroke-width': 2,
	// 		'stroke': "blue"
	// 	})

}





// Function launched when submit button clicked
function submitClick(event) {

	// Get name entered in form
	new_name = document.getElementById('name_val').value;
	new_sex = document.getElementById('sex_val').innerText;
	// Get first and last names from string
	name_split = new_name.split(" ");
	first_name = name_split[0];
	// console.log(first_name);
	last_name = name_split[1];
	url = "/get_d3_data/" + first_name + "/" + new_sex + "/" + start_yr;
	// Save current celeb name to global:
	celeb_name = first_name + " " + last_name;
	// Update rects with name birth values
	d3.json(url , function(json) {
		// Extract data from json dict into a JS array of values
		var dvals = Object.keys(json).map(function(k) { return [parseInt(k), json[k]]; });
		// Setup plot with this data
		update_rects(dvals);
	});

	url_movies = "/get_movie_data/" + first_name + "/" + last_name;
	d3.json(url_movies, function(json){
		// Extract list of objects from json wrapper
		movie_data = json.results;
		actor_id = json.actor_id;
		profile_url = json.profile_url;

		//Store first and last movie years in global variables
		min_movie_yr = d3.min(movie_data, function(d){return d.info.release;});
		max_movie_yr = d3.max(movie_data, function(d){return d.info.release;});

		//Plot the movie_data
		plot_movie_points(movie_data, actor_id);
		// ra = Object.keys(json).map(function(k) { return [k, json[k]]});
	});
	return false;
}

// Plot points for movies returned from server
function plot_movie_points(movie_json, actor_id) {
	// Make group in which to store movies
	if (movie_g) {
		movie_g
			.transition("remove_old_movies")
			.duration(100)
			.attr({"transform": "translate(0, 600)"})
			.remove();
	}
	movie_g = svg.append('g');
	// console.log(movie_json);
	// Add rects for movie data
	var movie_rects = movie_g.selectAll('rect')
				 .data(movie_json)
				 .enter()
				 .append('rect')
				 .attr({
					 'class': 'mrect',
					 'x': function(d) {return xScale(d.info.release)+xScale.rangeBand()/4;},
					 'y': -400,
					 'width': xScale.rangeBand()/2,
					 'height': function(d) {return (h-100);},
					 'fill': 'rgb(104,104,104)',
					 'fill-opacity': 0.8
				 })
				 .transition()
				 .duration(600)
				 .delay(function(d,i){return (i-1)*10;})
				 .attr({'y': function(d) {return 100;}});

	// Change scale to move viewport here


		movie_cull(movie_json, actor_id);

};



// Return promise for checking whether star features in movie or not
function cast_check_promise(actor_id, movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/cast_check/" + String(actor_id) + '/' + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			// Also security check in case no bool value (although should get error)
			} else if (result.result == null) {
				reject(result.error)
			// If no errors then send result to resolve function
			} else {
					// Add movie_id to object that we return
					result['movie_id'] = movie_id
					resolve(result);
			}
		});
	});
}

// Return promise for getting score of movie
function score_check_promise(movie_id) {
	return new Promise(function(resolve, reject) {
		//Build URL to check movie
		url = "/movie_score/" + String(movie_id);
		// Request JSON and pass results to resolve or reject accordingly
		d3.json(url, function(error, result) {
			// Check whether error and send to reject if so
			if (error) {
				reject(Error(error.statusText));
			} else {
				// console.log('RETURNING MOVIE SCORE, ', movie_id);
					// Pass back result and movie_id
					resolve([result, movie_id]);
			}
		});
	});
}




// Return promise for plotting rects - executed at end of queue
function score_rect_promise(response) {
	return new Promise(function(resolve, reject) {
		score_data = response[0];
		movie_id = response[1];
		console.log('RESPONSE IS ', response);
		// Here is where we call stuff for each movie update

		// Change movie class to 'scored' and bind score data
		new_scored_movie(movie_id, score_data);
		// Rescale all finished movies features based on new range if has changed:
		rescale_movies(score_data);
		// Update DOM rects based on new score data and rescale them if necessary
		adjust_rects_score();

		// Don't forget need to resolve promise in order to move on the chain!
		resolve()
	});
}

// Update class and data of newly scored movie
function new_scored_movie(movie_id, score_data) {
	// Get the movie we want to update class and data of:
	var update_movie = movie_g.selectAll('rect.mrect')
				 .filter(function(d) {return d.info.m_id == movie_id;});
	// Add feature values to the movies d3 __data__ attribute (so we can scale
	// them as new max/min features come in from subsequent movie api calls)
	// Add raw and scaled value (initially same)
	update_movie.data()[0].feat_raw = {};
	update_movie.data()[0].feat_scaled = {};
	update_movie.data()[0].feat_raw.pop = score_data.pop;
	update_movie.data()[0].feat_raw.vote = score_data.vote;
	update_movie.data()[0].feat_scaled.pop = score_data.pop;
	update_movie.data()[0].feat_scaled.vote = score_data.vote;

	// Note: Might be crucial that we do this AFTER above???
	// Add class 'scored' so can search for rects that have been updated
	update_movie.attr({
					 'class': 'mrect scored'
				 })

}


// Used by rescale function. TODO: Refactor.
// NOTE: CHANGED POP_MAX AND VOTE_MAX FROM 999 TO 0 ???
var pop_max = 0;
var vote_max = 0;
var score_lim = 0;
var popScale = d3.scale.linear()
							 .range([0,100]);
var voteScale = d3.scale.linear()
							 .range([0,100]);
var scoreScale = d3.scale.linear()
							 .range([h,0]);

function rescale_movies(score_data) {
	// Extract features into array
	vals = [score_data.pop, score_data.vote];
	// Check whether need to update max/min values for features
	// TODO: THIS IS HORRIBLE! VECTORIZE!
	// pop_lim[0] = d3.min([pop_lim[0], vals[0]]);
	pop_max = d3.max([pop_max, vals[0]]);
	// vote_lim[0] = d3.min([vote_lim[0], vals[1]]);
	vote_max = d3.max([vote_max, vals[1]]);
	// Update scales for normalizing pop,vote features & score
	popScale.domain([0, pop_max]);
	voteScale.domain([0, vote_max]);
	// Get all rects that are already scored
	// RAAA!!!!!!!!RAAA!!! When next crashes take a look at scored_rects
	// and see what pop value is of the movie that caused the trouble - whas it
	// removed inbetween being called? is feat_raw obj setup properly?
	scored_rects = movie_g.selectAll('rect.mrect.scored');
	// Now adjust pop and votes data attributes of scored rects with new scales
	scored_rects
				// each applies function to each element in selection - passing d,i
				 .each(function(d) {
				  newpop = popScale(d.feat_raw.pop);
				 	newvote = voteScale(d.feat_raw.vote);
					// Update pop and val attributes
					d.feat_scaled.pop = newpop;
					d.feat_scaled.vote = newvote;
					// Update score based on these new values
					d.score = calc_score(newpop, newvote);
					// Check whether need to update max value for scores
					// score_lim = d3.max([score_lim, calc_score(vals[0], vals[1])]);
				 });
}


var i = 0;
var transitions = {}
// Adjust movie rect according to scores as they're RECEIVED
// TODO: This function doesn't actually use the parameter passed to it! remove
function adjust_rects_score(score) { //!!!! Removed mov_id as paramter
	cols = ['green','red']
	i = (i+1)%2;
	// Update domain of scale that converts scores to y values for rects
	scored_rects = movie_g.selectAll('rect.mrect.scored')
	scores = scored_rects.data().map(function(d){return d.score;});
	// console.log(scores);
	min_score = d3.min(scores);
	// console.log('min: ', min_score);
	max_score = d3.max(scores);
	// CHANGED TO ZERO
	scoreScale.domain([0, max_score]);
	// Adjust rects of all scored movies
	// NOTE: Naming transition stops conflicts with other transitions but this
	// means that subsequent adjustments *here* can overwrite previous ones, but
	// that's ok since they only adjust visible y/height and not data we rely on
	movie_g.selectAll('rect.mrect.scored')
				 .transition("adjust_scores")
				 .duration(200)
				 .attr({
					 'fill': cols[i],
					//  Only reduce to minimum of 10px
					// 'y': function(d) {return scoreScale(d.score);}
					 'y': function(d) {var new_height = d3.min([scoreScale(d.score),h-10]); return new_height;},
					 'height': function(d) {var new_height = d3.min([scoreScale(d.score),h-10]); return h-new_height;}
				 });
}



function year_aggregator() {
	// Go through movies and if in same year then add scores and place new
	// rect, removing old ones.
	// Get all years that have movies
	years = movie_g.selectAll('rect.mrect.scored').data().map(function(d){return d.info.release;})
	// Find unique years
	years_unique = years.filter(function(val, idx, self) {return self.indexOf(val)===idx;})
	// Select all movies with that year - act on them if more than one

	// For finding max new combined score of all years (for rescale)
	max_comb_score = 0

	for (yr in years_unique) {
		// Note need to not include combined rects as they have no info data attr
		yr_movs = movie_g.selectAll('rect.mrect.scored').filter("*:not(.multi)").filter(function(d) {return d.info.release == years_unique[yr];})
		//TODO: IS REMOVING MORE MOVIES THAN SHOULD DO - LOOK HERE IN CASE IS MISSING
		if (yr_movs[0].length > 1) {
			// Create combined datum for all movies in this year
			// TODO: iterate through key values and collect

			comb_datum = yr_movs.data();
			//  Get combined score using aggregate function we define
			comb_score = comb_score_rule(comb_datum.map(function(d){return d.score;}));
			// Update max comb_score if necessary
			max_comb_score = d3.max([max_comb_score, comb_score]);
			// Get current data from multi selections
			new_data = movie_g.selectAll('rect.mrect.scored.multi').data();
			// Add new datum
			new_data.push({
				'multi_data':comb_datum,
				'score': comb_score,
				'info': {'release': years_unique[yr]}
				})
			// Create new rect with data for all movies in this year
			movie_g.selectAll('rect.mrect.scored.multi')
							// Add all the combined data as list in dict w key 'multi_data'
							.data(new_data)
							.enter()
							.append('rect')
							.attr({
								'class': 'mrect scored multi',
								// 'fill': 'pink',
								// 'y': 0,
								// 'height': 200,
								'x': function(d) {return xScale(years_unique[yr])+xScale.rangeBand()/4;},
								'width': xScale.rangeBand()/2
								// Note: y value will be set from score in rescale operation below
							})

			// Remove old rects
			// yr_movs.remove();
			// Name the transition in order to allow it to run concurrently.
			yr_movs.transition("remove_not_top_five")
						.duration(100)
						.attr({'y':-400})
						.remove();
			// Update rects y values due to new rescaled scores

			adjust_rects_score(max_comb_score);

		}
	}
	// Re-scale all rects
}



// This is called by adjust_rects_score and calcs score from features
function calc_score(pop, vote) {
	return pop+vote;
}

function comb_score_rule(score_list) {
	// Takes a list of scores and returns the combination by addition
	return score_list.reduce((a,b)=>a+b);
}


// Setup and act on promises for removing films based on cast-list
function movie_cull(movie_json) {
	// Setup promises to find which movies can ignore
	var cc_prom_list = [];
	// List to store movies that do feature actor
	starring_movs = []
	for (mov in movie_json) {
		// Get movie_id for current movie
		movie_id = movie_json[mov].info.m_id;
		// Create promise for querying api via server for actor in movie
		cc_prom = cast_check_promise(actor_id, movie_id).then(function(response){
			console.log('Success!', response);
			// Remove movie if fails test, otherwise add id to list
			if (response.result == false) {
				remove_movie_bar(response.movie_id);
			} else {
				keep_movie_bar(response.movie_id);
				starring_movs.push(response.movie_id);

			}
		}, function(error) {
			console.log('Failed :(', error);
		});
		// Add promise to array (so can use Promise.all to act when all complete)
		cc_prom_list.push(cc_prom);
	}
	// When all cast queries return then begin checking their scores.
	Promise.all(cc_prom_list).then(function(value) {
		// TODO: Here launch a re-check for all errors we had
		console.log('ALL DONE!!!!');
		// Setup promises for evaluating scores of remaining movies
		check_scores(starring_movs);
	});
}


// Setup and act on promises for removing films based on movie scores
function check_scores(starring_movs) {
	// List to store promises for each remaining movie
	var score_prom_list = []
	// Create promises that query api for score of each remaining movie
	for (mov_id in starring_movs) {
		// Create promise for this movie_id
		score_prom = score_check_promise(starring_movs[mov_id]).then(function(response){
			// On completion (data received) add a new promise to chain to alter d3
			update_rect_sequence = update_rect_sequence.then(function() {
				// Chain new promise to queue, passing json results and movie_id
				return score_rect_promise(response);
			}).then(function(response) {
				// Anything after each promise fulfilled from queue to go here
				// console.log('Just of top of queue is: ', response);
			})
		// Error from promise for getting score from api
		}, function(error) {
			console.log('Failed :(', error);
		});
		// Add initial (pre-queue) api promises to list for Promise.all
		score_prom_list.push(score_prom);
		}
	// Find when all promises have been added to update_rect_sequence queue
	Promise.all(score_prom_list).then(function(value) {
		// When all in queue, add final then to queue that triggers next part of viz
		update_rect_sequence.then(function() {
			console.log('SCORES ALL DONE!!!!');
			// TODO: CALCULATE TOP TEN WHEN HAVE ALL MOVIES HERE....
			//Using filter, sort or order?

			// Now combine scores from same year and replace multiple movies in single
			// year with one effective movie of added score
			year_aggregator();

			// Change any remaining to green
			// movie_g.selectAll('rect.mrect.scored')
			// 	.attr({'fill':'green'});

			// Now select only the top five scoring years
			var yr_sort = sort_scores();
			// Identify all except top 5 (for removal)
			var bottom = yr_sort.slice(5,yr_sort.length)
			console.log('GOT HERE....');
			// If extra vals, remove all but top five years, colour remaining black
			// and add listener for showing movies each year
			if (bottom.length>0) {
				movie_g.selectAll('rect.mrect.scored')
						.filter(function(d) {
							var crnt_yr = String(d.info.release);
							return (bottom.indexOf(crnt_yr) > -1);
						})
						.transition()
						.duration(1000)
						.attr({'y':-400})
						.call(endall, function() {
							// Colour remaining rects black when prev transition finished
							movie_g.selectAll('rect.mrect.scored')
								.on("mouseover", movie_name_fn)
								// NOTE: Need to name transition to allow it to run
								// concurrently with previous removal transition
								.transition("fade_to_black")
								.duration(900)
								.attr({'fill': 'black'})
								.call(endall, get_celeb_score);
								// .call(endall, get_celeb_score);
							// Call fn to get celeb score
						})
						.remove();

				} else {
					// If none to remove then just colour black & add listener
					movie_g.selectAll('rect.mrect.scored')
						.on("mouseover", movie_name_fn)
						.transition("fade_to_black")
						.duration(900)
						.attr({'fill': 'black'})
						.call(endall, get_celeb_score);

				}

				// Adjust any rects that are too small to see to be a minimum value of 10
				// movie_g.selectAll('rect.mrect.scored')
				// 			.filter(function(d) {return (this.getBBox().height < 10)})
				// 			.attr({
				// 				'y': function(d) {return scoreScale(10);},
				// 				'height': function(d) {return h-scoreScale(10);}
				// 			});


		}).then(function() {
			// Post data to controller to get score and significance in callback
			// get_celeb_score()

		});
	});
}

function endall(transition, callback) {
	var n = 0;
	transition
			.each(function() { ++n; })
			.each("end", function() { if (!--n) callback.apply(this, arguments); });
}

function get_celeb_score() {
	// Find years for celeb:
	celeb_yr_data = movie_g.selectAll('rect.mrect.scored').data();
	celeb_yrs = celeb_yr_data.map(function(d){return d.info.release}).sort();
	// Get all values within range of celebrities movies
	baby_vals = svg.selectAll('rect.barRect').data().filter(
				function(d) {
					if (d[0]>=min_movie_yr && d[0]<=max_movie_yr) {return d}
				});

	celeb_json = JSON.stringify({"celeb_yrs":celeb_yrs, "baby_vals":baby_vals});
	// TODO: Need to make sure that only send 5 (or whatever the top_number is)
	// so perhaps check length of celeb_yrs against top_number
	d3.json("/get_celeb_score").post(celeb_json, test_callback);
	// Expand text svg
	text_svg
	.transition()
	.duration(1000)
	.attr({'height':100})
	// Add waiting text
	// TODO: Put semantic loading anim too
	.call(endall, function(){
		text_svg.append('text')
		.text('Calculating score for ' + celeb_name + ' ...')
		.attr({
			'x': 100,
			'y': -10,
			'width': 92,
			'height':20,
			'fill': 'black',
			'font-size': 20
			// 'fill-opacity': 0
		})
		.transition("tran_2")
		.duration(300)
		.attr('y',50);
	});
}

function test_callback(error, score_data) {
	console.log(score_data);
	// Add text elements with score and confidence
	// Round values to required precision
	score = Math.round(score_data['celeb_score']*100000)/100000.0
	pval = Math.round(score_data['celeb_pval']*100)/100.0
	hyp_test = ['Score: '+score,'p-value: '+pval]
	text_svg
			.selectAll('text')
			.transition("remove_holder")
			.duration(300)
			.attr('y',-50)
			.remove()
			.call(endall, function() {
				text_svg.selectAll('text')
				.data(hyp_test)
				.enter()
				.append('text')
				.text(function(d){return d;})
				.attr({
					'x': function(d,i) {return (200+(i*300));},
					'y': 500,
					'width': 92,
					'height':20,
					'fill': 'black',
					'font-size': 25
					// 'fill-opacity': 0
				})
				.transition("add_score")
				.duration(1000)
				.attr('y',50);
			});

}


function movie_name_fn(d) {
	// Number of movies:
	if ('multi_data' in d) {
		num_mov = d.multi_data.length;
		mov_dat = d.multi_data;
	} else {
		num_mov = 1;
		mov_dat = [d];
	}

	// Add group of correct size

	img_base_url = "http://image.tmdb.org/t/p/w92";

	info_g = svg.append('g')
		.attr({'class': 'info'+String(d.release)})
		// PUT coordinates here using translate
	// Now add further g's inside for each movie at necessary locations
	info_g.selectAll('image')
				.data(mov_dat)
				.enter()
				.append('image')
				.attr({
					'xlink:href': function(d) {
						if (d['info']['poster']) {
							return img_base_url+String(d['info']['poster']);
						} else {
							return img_base_url+String(profile_url);
						}
					},
					'x': function(d,i) {return i*92-50;},
					'y': 0,
					'width': 92,
					'height': 138,
					'opacity': 0
				})
				.transition()
				.delay(function(d,i) {return i*200})
				.duration(400)
				.attr({
					'x': function(d,i) {return i*92;},
					'opacity': 1
				})
	// Add text under movie images
				.each(function(d,i) {
					title = d.info.title
					info_g
								.append('text')
								.text(title)
								.attr({
									'x': i*92-50,
									'y': 160,
									'width': 92,
									'height':20,
									'fill': 'black',
									'fill-opacity': 0
								})
								.transition()
								.delay(function(d,i) {return i*200})
								.duration(400)
								.attr({
									'x': i*92,
									'fill-opacity': 1
								})
				})
	// Add mouseout event for removing pics when leave
	current_yr = d.info.release;
	movie_g.selectAll('rect.mrect.scored')
		.filter(function(d) {return d.info.release == current_yr})
		.on("mouseout", function(d){
			info_g.selectAll('text')
				.transition()
				.delay(500)
				.duration(800)
				.attr({'fill-opacity': 0})
				.remove();
			info_g.selectAll('image')
				.transition()
				.delay(500)
				.duration(800)
				.attr({'opacity': 0})
				.remove();

		})


}



// 92 x 138
// TODO: URL construct for movie posters:
// http://image.tmdb.org/t/p/w92/jojz3Yw5tEqtILcqbEsO0GLEIJm.jpg
// Find movies associated with actor/actress
// act_name = "Humphrey Bogart";
// Get movie data (currently defaults to server-set name)
// TODO: Have use user-entered name
// TODO: Have suggest possibilities on multiple returns

function sort_scores() {
	// Returns years sorted by scores, descending
	// Select all years
	all_yrs = movie_g.selectAll('rect.mrect.scored').data();
	// Create object with years as keys and associated scores as values
	yrs_scores = {};
	all_yrs.map(function(d){yrs_scores[d.info.release]=d.score;});
	// Sort object keys (years) based on values (scores)
	sorted_yrs = Object.keys(yrs_scores).sort(function(a,b){return yrs_scores[b]-yrs_scores[a]});
	// Select top five
	return sorted_yrs;
}


// TODO: NEED TO NORMALIZE BOTH THE FEATURES AND THEN ALSO THE TOTAL VALUE TO PLOT

// var mrect_scale = d3.scale.linear()
// 							 .domain([0, d3.max(new_dataset)])
// 							 .range([h,0]);
var max_rect = 0;
var min_rect = 0;


// movie_g.selectAll('rect.mrect').attr('height', function(d){return (h-d3.select(this).attr('y'));});

function keep_movie_bar(keep_val) {
	current_mov = movie_g.selectAll('rect.mrect')
									.filter(function(d){return d.info.m_id==keep_val;});

	// Flash up movie name as it is kept
	// Get movie name, x val from movie
	mov_data = current_mov.data()[0].info;
	// Get existing data of text on screen (in case concurently remove two)
	text_data = movie_g.selectAll('text.mtext').data();
	// Add data for new text we want to add
	text_data.push(mov_data);

	// Re-bind data with new element and add new text animation
	movie_g.selectAll('text.mtext')
					 .data(text_data)
					 .enter()
					 .append('text')
					 .text(function(d){return d.title;})
					 .attr({
						'class': 'mtext',
						'x': function(d) {return xScale(d.release);},
						'y':100,
						'fill':'green',
						'fill-opacity':0
					 })
						// Rotate text ninety degrees
					 .attr('transform',function(d,i){
						return 'rotate(-90,'+d3.select(this).attr("x")+','+d3.select(this).attr("y")+')';})
					 .transition()
					 .duration(800)
					 .attr({
						'fill-opacity':1,
						'x':function(d) {return xScale(d.release)+20;}
					 })
					 .transition()
					 .delay(800)
					 .duration(800)
					 .attr({
						'fill-opacity':0,
						'x': function(d) {return xScale(d.release);}
					 })
					 .remove()


}

// Removes a bar and text downwards when movie culled
function remove_movie_bar(remove_val) {
	current_mov = movie_g.selectAll('rect.mrect')
									.filter(function(d){return d.info.m_id==remove_val;});

	// Flash up movie name as it dissapears
	// Get movie name, x val from movie
	mov_data = current_mov.data()[0].info;
	// Get existing data of text on screen (in case concurently remove two)
	text_data = movie_g.selectAll('text.mtext').data();
	// Add data for new text we want to add
	text_data.push(mov_data);

	// Remove rect
	current_mov
				 .transition()
				 .duration(500)
				 .attr('y',1000)
				 .remove();


	// Re-bind data with new element and add new text animation
	movie_g.selectAll('text.mtext')
					 .data(text_data)
					 .enter()
					 .append('text')
					 .text(function(d){return d.title;})
					 .attr({
						'class': 'mtext',
						'x': function(d) {return xScale(d.release);},
						'y':100,
						'fill':'red',
					  'fill-opacity':0
					 })
						// Rotate text ninety degrees
					 .attr('transform',function(d,i){
	 					return 'rotate(-90,'+d3.select(this).attr("x")+','+d3.select(this).attr("y")+')';})
					 .transition()
					 .duration(800)
					 .attr({
						'fill-opacity':1,
						'x':function(d) {return xScale(d.release)+20;}
					 })
					 .transition()
					 .delay(800)
					 .duration(800)
					 .attr({
						'fill-opacity':0,
						'x': function(d) {return xScale(d.release);}
					 })
					 .remove()


	// // Remove associated text
	// movie_g.selectAll('text.mtext')
	// 			 .filter(function(d) {return d.info.m_id == remove_val;})
	// 			 .transition()
	// 			 .duration(500)
	// 			 .attr('x',-1000)
	// 			 .remove();
}

// Update rects for name history when new data to be bound
function update_rects(new_dataset) {
	// Update yscale
	yScale = d3.scale.linear()
								 .domain([0, d3.max(new_dataset, function(d){return d[1];})])
								 .range([h,0]);
	//Update rects
	svg.selectAll('rect.barRect')
		 .data(new_dataset)
		 .transition()
		 .delay(function(d,i) {return i/131 * 500;})
		 .duration(950)
		 .attr({
			 'y': function(d) {return yScale(d[1]);},
			 'height': function(d) {return h-yScale(d[1]);},
			 'fill': function(d) {
								return 'rgb(200,0,'+Math.floor((1-yScale(d[1])/h)*255) +')';
								}
			});
}

</script>

{% endblock %}
